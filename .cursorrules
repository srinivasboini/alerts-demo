# Clean Architecture Rules for Alerts Application

# Project Structure
project_structure:
  - com.example.alerts
    - application
      - port
        - in
        - out
      - service
    - domain
      - model
    - infrastructure
      - adapter
        - in
          - web
        - out
          - persistence
      - config
      - exception

# Layer Dependencies
dependencies:
  - domain: []
  - application: [domain]
  - infrastructure: [application, domain]

# Naming Conventions
naming:
  - classes: PascalCase
  - methods: camelCase
  - variables: camelCase
  - constants: UPPER_SNAKE_CASE
  - packages: lowercase

# Package Naming Conventions
package_naming:
  - domain:
    - models: com.example.alerts.domain.model
  - application:
    - ports: com.example.alerts.application.port
    - services: com.example.alerts.application.service
  - infrastructure:
    - adapters: com.example.alerts.infrastructure.adapter
    - config: com.example.alerts.infrastructure.config
    - exception: com.example.alerts.infrastructure.exception

# Architecture Rules
rules:
  - domain_layer:
    - contains: business models, entities, value objects
    - no_dependencies: true
    - annotations: none
  - application_layer:
    - contains: use cases, ports, services
    - depends_on: domain
    - annotations: @Service
  - infrastructure_layer:
    - contains: adapters, configurations, external services
    - depends_on: application, domain
    - annotations: @Configuration, @Component, @Repository

# Spring Boot Specifics
spring_boot:
  - version: 3.x
  - java_version: 17+
  - annotations:
    - @SpringBootApplication: AlertsApplication
    - @RestController: Web Adapters
    - @Service: Application Services
    - @Repository: Persistence Adapters
    - @Configuration: Infrastructure Configs

# Java 17 Features
java_17_features:
  - records:
    - use_for: immutable data classes
    - example: domain models
    - benefits: conciseness, immutability, equals/hashCode/toString
  - sealed_classes:
    - use_for: restricted class hierarchies
    - example: transaction types, fraud types
    - benefits: type safety, pattern matching
  - pattern_matching:
    - use_for: instanceof checks
    - example: switch expressions
    - benefits: cleaner code, type safety
  - text_blocks:
    - use_for: multi-line strings
    - example: SQL queries, JSON templates
    - benefits: readability, maintainability
  - switch_expressions:
    - use_for: complex conditional logic
    - example: status handling
    - benefits: conciseness, exhaustiveness
  - local_variable_type_inference:
    - use_for: local variables
    - example: var in for loops
    - benefits: reduced boilerplate
  - null_checks:
    - use_for: Optional API
    - example: repository returns
    - benefits: null safety

# Testing Structure
testing:
  - unit_tests: same_package_as_source
  - integration_tests: src/test/java
  - test_naming: *Test.java
  - test_annotations:
    - @SpringBootTest: Integration Tests
    - @DataJpaTest: Repository Tests
    - @WebMvcTest: Controller Tests

# Logging
logging:
  - use: @Slf4j from Lombok
  - levels:
    - ERROR: system errors, exceptions
    - WARN: potential issues
    - INFO: business operations
    - DEBUG: detailed debugging
  - format: "[{}] {}" for structured logging
  - context: include relevant IDs and counts

# Error Handling
error_handling:
  - use: @ControllerAdvice for global handling
  - custom_exceptions: extend RuntimeException
  - http_status: appropriate status codes
  - logging: include stack traces for errors

# API Design
api_design:
  - versioning: /api/v1/
  - naming: plural nouns for resources
  - methods: proper HTTP verbs
  - responses: consistent format
  - documentation: OpenAPI/Swagger

# Security
security:
  - authentication: Spring Security
  - authorization: role-based
  - validation: Bean Validation
  - sanitization: input validation
  - headers: security headers

# Performance
performance:
  - caching: Spring Cache
  - async: @Async for long operations
  - pagination: for large datasets
  - indexing: database optimization
  - monitoring: Spring Actuator

You are an expert in Java programming, Spring Boot, Spring Framework, Maven, JUnit, and related Java technologies.

Code Style and Structure
- Write clean, efficient, and well-documented Java code with accurate Spring Boot examples.
- Use Spring Boot best practices and conventions throughout your code.
- Implement RESTful API design patterns when creating web services.
- Use descriptive method and variable names following camelCase convention.
- Structure Spring Boot applications: controllers, services, repositories, models, configurations.

Spring Boot Specifics
- Use Spring Boot starters for quick project setup and dependency management.
- Implement proper use of annotations (e.g., @SpringBootApplication, @RestController, @Service).
- Utilize Spring Boot's auto-configuration features effectively.
- Implement proper exception handling using @ControllerAdvice and @ExceptionHandler.

Naming Conventions
- Use PascalCase for class names (e.g., UserController, OrderService).
- Use camelCase for method and variable names (e.g., findUserById, isOrderValid).
- Use ALL_CAPS for constants (e.g., MAX_RETRY_ATTEMPTS, DEFAULT_PAGE_SIZE).

Java and Spring Boot Usage
- Use Java 17 or later features when applicable (e.g., records, sealed classes, pattern matching).
- Leverage Spring Boot 3.x features and best practices.
- Use Spring Data JPA for database operations when applicable.
- Implement proper validation using Bean Validation (e.g., @Valid, custom validators).

Configuration and Properties
- Use application.properties or application.yml for configuration.
- Implement environment-specific configurations using Spring Profiles.
- Use @ConfigurationProperties for type-safe configuration properties.

Dependency Injection and IoC
- Use constructor injection over field injection for better testability.
- Leverage Spring's IoC container for managing bean lifecycles.

Testing
- Write unit tests using JUnit 5 and Spring Boot Test.
- Use MockMvc for testing web layers.
- Implement integration tests using @SpringBootTest.
- Use @DataJpaTest for repository layer tests.

Performance and Scalability
- Implement caching strategies using Spring Cache abstraction.
- Use async processing with @Async for non-blocking operations.
- Implement proper database indexing and query optimization.

Security
- Implement Spring Security for authentication and authorization.
- Use proper password encoding (e.g., BCrypt).
- Implement CORS configuration when necessary.

Logging and Monitoring
- Use SLF4J with Logback for logging.
- Implement proper log levels (ERROR, WARN, INFO, DEBUG).
- Use Spring Boot Actuator for application monitoring and metrics.

API Documentation
- Use Springdoc OpenAPI (formerly Swagger) for API documentation.

Data Access and ORM
- Use Spring Data JPA for database operations.
- Implement proper entity relationships and cascading.
- Use database migrations with tools like Flyway or Liquibase.

Build and Deployment
- Use Maven for dependency management and build processes.
- Implement proper profiles for different environments (dev, test, prod).
- Use Docker for containerization if applicable.

Follow best practices for:
- RESTful API design (proper use of HTTP methods, status codes, etc.).
- Microservices architecture (if applicable).
- Asynchronous processing using Spring's @Async or reactive programming with Spring WebFlux.

Adhere to SOLID principles and maintain high cohesion and low coupling in your Spring Boot application design.
    